# 常见类型（Everyday Types）

## 目录

- [常见类型（Everyday Types）](#常见类型everyday-types)
  - [目录](#目录)
  - [原始类型（The primitives）](#原始类型the-primitives)
  - [数组（Array）](#数组array)
  - [any](#any)
    - [当一个值是 any 类型](#当一个值是-any-类型)
    - [noImplicitAny](#noimplicitany)
  - [变量上的类型注解（Type Annotations on Variables）](#变量上的类型注解type-annotations-on-variables)
  - [函数（Function）](#函数function)
    - [参数类型注解（Parameter Type Annotations）](#参数类型注解parameter-type-annotations)
    - [返回值类型注解（Return Type Annotations）](#返回值类型注解return-type-annotations)
    - [匿名函数（Anonymous Functions）](#匿名函数anonymous-functions)
  - [对象类型（Object Types）](#对象类型object-types)
    - [可选属性（Optional Properties）](#可选属性optional-properties)
  - [联合类型（Union Types）](#联合类型union-types)
    - [定义一个联合类型（Defining a Union Type）](#定义一个联合类型defining-a-union-type)
    - [使用联合类型（Working with Union Types）](#使用联合类型working-with-union-types)
      - [如何使用符合一个联合类型的值](#如何使用符合一个联合类型的值)
  - [启示](#启示)

## 原始类型（The primitives）

- string
- number
- boolean
- String、Number、Boolean 也是合法的，但它们是一些非常少见的特殊内置类型。所以类型总是使用上述提到的三者。

## 数组（Array）

- number[]
  - 表示一个数字数组
  - 与泛型 Array\<number> 意义一致
- string[]
  - 表示一个字符数组
  - 与泛型 Array\<string> 意义一致
- 注意 [number] 表示元组

## any

当不希望一个值导致类型检查错误的时候，就可以设置其为 any 类型

### 当一个值是 any 类型

- 可以获取它的任意属性
  - 属性也会被转为 any 类型
- 像函数一样调用它
- 将它赋值给一个任意类型的值
- 将任意类型的值赋值给它
- 其他任何语法正确的操作

```typescript
let obj: any = { x: 0 };
// None of the following lines of code will throw compiler errors.
// Using 'any' disables all further type checking, and it is assumed you know the environment better than TypeScript

obj.foo();
obj();
obj.bar = 100;
obj = "hello";
const n: number = obj;
```

### noImplicitAny

如果没有对变量指定一个类型，TS 也不能从上下文推断出它的类型，编译器就会默认设置为 any 类型。

如果想要避免上述情况，（TS 不对 any 类型做类型检查），可以开启编译选项 noImplicitAny，当变量被隐式推断为 any 类型时，TS 会报错。

## 变量上的类型注解（Type Annotations on Variables）

当使用 const、let、var 关键字声明一个变量时，可以选择性的添加一个类型注解，显式指定变量的类型

大部分时候，上述操作不是必须的。因为 TS 会自动推断类型

e.g. 变量的类型可以基于初始值进行推断

```typescript
// No type annotation needed -- 'myName' inferred as type 'string'
let myName = "Alice";
```

## 函数（Function）

函数是 JS 传递数据的主要方法。TS 允许指定函数的输入值和输出值的类型

### 参数类型注解（Parameter Type Annotations）

```typescript
// Parameter type annotation
function greet(name: string) {
    console.log("Hello, " + name.toUpperCase() + "!!");
}

// Would be a runtime error if executed!
greet(42);
// Argument of type 'number' is no assignable to parameter of type 'string'
```

注：即便没有对参数做类型注解，TS 仍然会检查传入参数的数量是否正确

### 返回值类型注解（Return Type Annotations）

- TS 会根据 return 语句推断函数的返回类型
- 显式指定返回值类型可能有以下需求
  - 需要编写文档
  - 阻止意外修改
  - 个人喜好
  
### 匿名函数（Anonymous Functions）

匿名函数有一点不同于函数声明，当 TS 知道一个匿名函数将被怎样调用时，匿名函数的参数会被自动的指定类型。

```typescript
// No type annotations herr, but TypeScript can spot the bug
const names = ["Alice", "Bob", "Eve"];

// Contextual typing for function
names.forEach(function (s) {
    console.log(s.toUppercase());
    // Property 'toUppercase' does not exist on type 'string'. Did you mean 'toUpperCase'?
});

// Contextual typing also applies to arrow functions
names.forEach((s) => {
    console.log(s.toUppercase());
    // Property 'toUppercase' does not exist on type 'string'. Did you mean 'toUpperCase'?
});
```

尽管参数 s 并没有添加类型注解，但是 TS 根据 forEach() 的类型，以及传入的数组的类型，最终推断出了 s 的类型

上述过程被称为 **上下文推断（contextual typing）**

## 对象类型（Object Types）

定义一个对象类型，只需要简单的列出它的属性和对应的类型即可。

```typescript
// The parameter's type annotation is an object type
function printCoord(pt: { x: number; y: number }) {
    console.log("The coordinate's x value is " + pt.x);
    console.log("The coordinate's y value is " + pt.y);
}

printCoord({x: 3, y: 7});
```

上述例子中，为参数 pt 添加了一个类型，该类型有两个属性 x 和 y，两个都是 number 类型，可以使用 , / ; 符号属性分隔开，最后一个属性的分隔符可加可不加。

每个属性对应的类型都是可选的，默认使用 any 类型。

### 可选属性（Optional Properties）

对象类型可以指定一些甚至所有的属性为可选，只需在属性名后添加符号 ?

```typescript
function printName(obj: { first: string; last?: string }) {
    // ...
}

// Both OK
printName({ first: "Bob" });
printName({ first: "Alice", last: "Alisson" });
```

在 JS 中，如果获取一个不存在属性，会得到一个 undefined 而不是运行时错误。

基于上述条件，当获取一个可选属性时，需要在使用它前，先检查其是否为 undefined。

```typescript
function printName(obj: { first: string; last?: string }) {
    // Error - might crash if 'obj.last' wasn't provied!
    console.log(obj.last.toUpperCase());

    // Object is possibly 'undefined'
    if (obj.last !== undefined) {
        // OK
        console.log(obj.last.toUpperCase());
    }

    // A safe alternative using modern JavaScript syntax:
    console.log(obj.last?.toUpperCase());
}
```

## 联合类型（Union Types）

TS 类型系统允许使用一系列的操作符，基于已经存在的类型构建新的类型。

### 定义一个联合类型（Defining a Union Type）

一个联合类型是由两个或者更多类型组成的类型，表示值可能是这些类型中的任意一个。

```typescript
function printId(id: number | string) {
    console.log("Your ID is: " + id);
}

// OK
printId(101);
// OK
printId("202");
// Error
printId({ myID: 22342 });
// Argument of type '{ myID: number; }' is not assignable to parameter of type 'string | number'.
// Type '{ myID: number; }' is not assignable to type 'number'.
```

### 使用联合类型（Working with Union Types）

提供一个符合联合类型的值很容易，只需要提供符合一个联合类型成员类型的值即可。

#### 如何使用符合一个联合类型的值

TS 会要求你做的事情，必须对每个联合的成员都是有效的。

e.g. 如有一个联合类型 string | number，不能使用只存在 string 上的方法

```typescript
function printId(id: number | string) {
    console.log(id.toUpperCase());
    // Property 'toUpperCase' does not exist on type 'string | number'
    // Property 'toUpperCase' does not exist on type 'number'
}
```

上述问题的解决方案为：代码收窄联合类型，就像在 JS 没有类型注解那样使用。

当 TS 可以根据代码的结构推断出一个更具体的类型时，类型收窄就会出现。

```typescript
function printId(id: number | string) {
    if (typeof id === 'string') {
        // In this  branch, id is of type 'string'
        console.log(id: toUpperCase());
    } else {
        // Here, id is of type 'number'
        console.log(id);
    }
}

console.log("=============")

function welcomePeople(x: string[] | string) {
    if (Array.isArray(x)) {
        // Here: 'x' is 'string[]'
        console.log("Hello, " + x.join(" and "));
    } else {
        // Here: 'x' is 'string'
        console.log("Welcome lone traveler " + x)
    }
}

```

如果联合类型的每个成员类型都一个属性，那么直接使用这个属性，而不用做类型收窄。

```typescript
// Return typr is inferred as number[] | string
function getFirstThree(x: number[] | string) {
    return x.slice(0, 3);
}
```

## 启示

你可能很奇怪，为什么联合类型只能使用这些类型属性的交集，让我们举个例子，现在有两个房间，一个房间都是身高八尺戴帽子的人，另外一个房间则是会讲西班牙语戴帽子的人，合并这两个房间后，我们唯一知道的事情是：每一个人都戴着帽子。
