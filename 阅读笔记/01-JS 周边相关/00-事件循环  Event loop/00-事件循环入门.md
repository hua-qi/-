# JS 事件循环入门

JS：单线程（single-threaded）、非阻塞（non-blocking）、异步（asynchronous）、并发（concurrent）的语言

拥有一个调用栈（call stack）、一个事件循环（event loop）、一个回调队列（callback queue）、一些 api 以及其他的东西

## 目录

- [JS 事件循环入门](#js-事件循环入门)
  - [目录](#目录)
  - [JS 引擎简介](#js-引擎简介)
  - [浏览器提供的 JS 运行时环境](#浏览器提供的-js-运行时环境)
  - [JS 的单线程意味着什么](#js-的单线程意味着什么)
  - [并发 与 事件循环](#并发-与-事件循环)
    - [事件循环做了什么事情](#事件循环做了什么事情)
    - [渲染任务](#渲染任务)
  - [tips](#tips)
    - [setTimeout 的时间相关](#settimeout-的时间相关)
    - [回调函数的含义](#回调函数的含义)

## JS 引擎简介

![JS 引擎简介](../00-事件循环%20%20Event%20loop/images/JS%20引擎简介图.png)

拥有一个用于分配内存的堆，以及一个存放执行上下文的栈。

## 浏览器提供的 JS 运行时环境

![浏览器提供的 JS 运行时环境](./images/浏览器提供的%20JS%20运行时环境.png)

如图，DOM、XMLHttpRequest、setTimeout 等是浏览器提供的 WebAPIs，并非是 JS 原生语言提供的能力。

当然 JS 运行在 Node 提供的运行时环境时，结构与和上图类似，不过使用的 setTimeout、readFile 等是 Node 提供的 C++ APIs。

## JS 的单线程意味着什么

one thread === one call stack === one thing at a time

- 函数报错时，可以体现调用栈轨迹
  - call stack 中的函数运行时报错，可以在浏览器的 devtools 中体现出调用栈轨迹（当然如果时回调函数报错，可能就没有了 ）
- 同步代码耗时过长时，会造成**调用栈阻塞**
  - 而浏览器的渲染任务亦是需要等待 调用栈清空后，才可以执行
  - 异步任务会在上一个渲染任务执行完毕，进入调用栈中进行执行

## 并发 与 事件循环

JS 同一时刻只能做一件事，但是浏览器提供了其他东西，即 WebAPIs。它们会对应地创建一些线程，但是不能直接访问，只能通过接口进行调用，然后浏览对这些调用进行响应。

### 事件循环做了什么事情

1. 查看调用栈和任务队列
2. 如果调用栈为空，那么就把任务队列队头的任务压入栈中，之后这个任务得到执行  

### 渲染任务

浏览器每 16.6 毫秒会对页面进行一次重绘，使页面保持在每秒 60 帧。

重绘受 JS 影响，在调用栈尚未清空时，是无法进行重绘的。

渲染队列的优先级高于回调任务队列优先级。

## tips

### setTimeout 的时间相关

- 设置 setTimeout 的时间为 0 的意义是什么，使该事件在栈底（或者说 空栈）中执行
- 设置的时间，指的并不是多久之后执行，而是最快要多久之后执行

### 回调函数的含义

- 被其他函数调用的函数
- 在将来的某个时刻会进入队列的异步回调
